import fs from "fs";
import path from "path";

const TOTAL_QUESTIONS_PER_EXAM = 225;
const NUM_EXAMS = 4;
const SHORT_EXAM_SIZE = 83; // diagnostic exam size (one per JSON file)
const SHORT_EXAM_COUNT = 4;
const UNSCORED_FRACTION = 0.2; // 20% of questions are difficult and unscored for 225-question exams

// Domain weightings (as proportions of the total exam)
const DOMAIN_WEIGHTS = {
  1: 0.10, // Biological bases of behavior
  2: 0.13, // Cognitive-affective bases of behavior
  3: 0.11, // Social and cultural bases of behavior
  4: 0.12, // Growth and lifespan development
  5: 0.16, // Assessment and diagnosis
  6: 0.15, // Treatment, intervention, prevention, supervision
  7: 0.07, // Research methods and statistics
  8: 0.16, // Ethical, legal, and professional issues
};

const ROOT_DIR = path.resolve(process.cwd());
// Questions generated by tools/generate-questions.js
const QUESTIONS_DIR = path.resolve(ROOT_DIR, "..", "questionsGPT");
// Output directory for practice exams
const EXAMS_DIR = path.resolve(ROOT_DIR, "..", "examsGPT");
// Output directory for diagnostic exams
const DIAGNOSTIC_EXAMS_DIR = path.resolve(ROOT_DIR, "..", "diagnosticGPT");

function ensureDirExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

function listJsonFiles(dirPath) {
  if (!fs.existsSync(dirPath)) {
    throw new Error(`Questions directory not found: ${dirPath}`);
  }

  const files = [];
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      files.push(...listJsonFiles(fullPath));
    } else if (entry.isFile() && path.extname(entry.name).toLowerCase() === ".json") {
      files.push(fullPath);
    }
  }

  return files;
}

function knToDomain(kn) {
  if (!kn || typeof kn !== "string") return null;
  const match = kn.match(/KN(\d{1,2})/i);
  if (!match) return null;
  const n = Number(match[1]);
  if (n >= 1 && n <= 5) return 1;
  if (n >= 6 && n <= 13) return 2;
  if (n >= 14 && n <= 20) return 3;
  if (n >= 21 && n <= 28) return 4;
  if (n >= 29 && n <= 41) return 5;
  if (n >= 42 && n <= 52) return 6;
  if (n >= 53 && n <= 60) return 7;
  if (n >= 61 && n <= 71) return 8;
  return null;
}

function loadQuestionsByDomain() {
  const files = listJsonFiles(QUESTIONS_DIR);
  const questionsByDomain = {
    1: [],
    2: [],
    3: [],
    4: [],
    5: [],
    6: [],
    7: [],
    8: [],
  };

  const allQuestions = [];
  let totalLoaded = 0;

  for (const file of files) {
    let parsed;
    try {
      const raw = fs.readFileSync(file, "utf-8");
      parsed = JSON.parse(raw);
    } catch (err) {
      console.warn(`Warning: Failed to read/parse ${file}: ${err.message}`);
      continue;
    }

    if (!parsed || typeof parsed !== "object" || !Array.isArray(parsed.questions)) {
      console.warn(`Warning: File ${file} does not contain a "questions" array; skipping.`);
      continue;
    }

    parsed.questions.forEach((q, index) => {
      const domain = knToDomain(q.kn);
      if (!domain) {
        // Skip questions without a valid KN mapping
        return;
      }

      const withMeta = {
        ...q,
        sourceFile: file,
        domain,
        id: `${file}::${index}`,
      };

      questionsByDomain[domain].push(withMeta);
      allQuestions.push(withMeta);
      totalLoaded += 1;
    });
  }

  console.log("Loaded questions by domain:");
  for (let d = 1; d <= 8; d += 1) {
    console.log(`  Domain ${d}: ${questionsByDomain[d].length} questions`);
  }
  console.log(`Total questions loaded: ${totalLoaded}`);

  return { questionsByDomain, allQuestions };
}

function computeTargetCounts(totalQuestions) {
  const targets = {};
  const fractions = {};

  let baseSum = 0;
  for (let d = 1; d <= 8; d += 1) {
    const exact = DOMAIN_WEIGHTS[d] * totalQuestions;
    const base = Math.floor(exact);
    const frac = exact - base;
    targets[d] = base;
    fractions[d] = frac;
    baseSum += base;
  }

  let remaining = totalQuestions - baseSum;
  if (remaining > 0) {
    const sortedDomains = Object.keys(fractions)
      .map((d) => Number(d))
      .sort((a, b) => fractions[b] - fractions[a]);
    for (const d of sortedDomains) {
      if (remaining <= 0) break;
      targets[d] += 1;
      remaining -= 1;
    }
  }

  return targets;
}

function shuffleInPlace(array) {
  for (let i = array.length - 1; i > 0; i -= 1) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function buildExamWithCoverage(allQuestions, questionsByDomain, targets, examSize) {
  const selected = [];
  const usedIds = new Set();
  const domainCounts = {};
  for (let d = 1; d <= 8; d += 1) {
    domainCounts[d] = 0;
  }

  // Build helper maps: by source file and by KN
  const questionsByFile = {};
  const questionsByKN = {};

  for (const q of allQuestions) {
    if (!questionsByFile[q.sourceFile]) {
      questionsByFile[q.sourceFile] = [];
    }
    questionsByFile[q.sourceFile].push(q);

    if (q.kn) {
      if (!questionsByKN[q.kn]) {
        questionsByKN[q.kn] = [];
      }
      questionsByKN[q.kn].push(q);
    }
  }

  // 1) Ensure at least one question from each JSON file
  for (const file of Object.keys(questionsByFile)) {
    const pool = questionsByFile[file].filter((q) => !usedIds.has(q.id));
    if (pool.length === 0) {
      continue;
    }
    const choice = pool[Math.floor(Math.random() * pool.length)];
    selected.push(choice);
    usedIds.add(choice.id);
    domainCounts[choice.domain] += 1;
  }

  // 2) Ensure at least one question for each KN present in the bank
  for (const kn of Object.keys(questionsByKN)) {
    const alreadyHasKN = selected.some((q) => q.kn === kn);
    if (alreadyHasKN) {
      continue;
    }
    const pool = questionsByKN[kn].filter((q) => !usedIds.has(q.id));
    if (pool.length === 0) {
      // All questions for this KN were already taken via file coverage
      continue;
    }
    const choice = pool[Math.floor(Math.random() * pool.length)];
    selected.push(choice);
    usedIds.add(choice.id);
    domainCounts[choice.domain] += 1;
  }

  if (selected.length > examSize) {
    throw new Error(
      `Forced coverage (files + KNs) requires ${selected.length} questions, which exceeds the exam size of ${examSize}.`,
    );
  }

  // 3) Fill remaining slots, aiming to match domain targets
  while (selected.length < examSize) {
    const remainingSlots = examSize - selected.length;

    // Compute domain deficits vs targets
    const domainWeights = {};
    let weightSum = 0;

    for (let d = 1; d <= 8; d += 1) {
      const pool = questionsByDomain[d].filter((q) => !usedIds.has(q.id));
      if (pool.length === 0) {
        continue;
      }
      const deficit = Math.max((targets[d] || 0) - domainCounts[d], 0);
      const weight = deficit + 0.1; // small epsilon so domains without deficit can still be chosen
      domainWeights[d] = { pool, weight };
      weightSum += weight;
    }

    if (weightSum === 0) {
      // No available questions left (shouldn't usually happen)
      break;
    }

    // Randomly pick a domain proportional to its weight
    let r = Math.random() * weightSum;
    let chosenDomain = null;
    for (let d = 1; d <= 8; d += 1) {
      const entry = domainWeights[d];
      if (!entry) continue;
      if (r < entry.weight) {
        chosenDomain = d;
        break;
      }
      r -= entry.weight;
    }

    if (!chosenDomain) {
      // Fallback: pick any domain with available questions
      const availableDomains = Object.keys(domainWeights).map((d) => Number(d));
      chosenDomain = availableDomains[Math.floor(Math.random() * availableDomains.length)];
    }

    const { pool } = domainWeights[chosenDomain];
    const choice = pool[Math.floor(Math.random() * pool.length)];
    selected.push(choice);
    usedIds.add(choice.id);
    domainCounts[chosenDomain] += 1;

    if (remainingSlots - 1 <= 0) {
      break;
    }
  }

  // Shuffle overall exam order so domains and sources are mixed
  shuffleInPlace(selected);

  return selected;
}

function buildExamSimple(questionsByDomain, targets, examSize) {
  const selected = [];
  const usedIds = new Set();
  const domainCounts = {};
  for (let d = 1; d <= 8; d += 1) {
    domainCounts[d] = 0;
  }

  while (selected.length < examSize) {
    const remainingSlots = examSize - selected.length;

    const domainWeights = {};
    let weightSum = 0;

    for (let d = 1; d <= 8; d += 1) {
      const pool = questionsByDomain[d].filter((q) => !usedIds.has(q.id));
      if (pool.length === 0) continue;
      const deficit = Math.max((targets[d] || 0) - domainCounts[d], 0);
      const weight = deficit + 0.1;
      domainWeights[d] = { pool, weight };
      weightSum += weight;
    }

    if (weightSum === 0) break;

    let r = Math.random() * weightSum;
    let chosenDomain = null;
    for (let d = 1; d <= 8; d += 1) {
      const entry = domainWeights[d];
      if (!entry) continue;
      if (r < entry.weight) {
        chosenDomain = d;
        break;
      }
      r -= entry.weight;
    }

    if (!chosenDomain) {
      const availableDomains = Object.keys(domainWeights).map((d) => Number(d));
      chosenDomain = availableDomains[Math.floor(Math.random() * availableDomains.length)];
    }

    const { pool } = domainWeights[chosenDomain];
    const choice = pool[Math.floor(Math.random() * pool.length)];
    selected.push(choice);
    usedIds.add(choice.id);
    domainCounts[chosenDomain] += 1;

    if (remainingSlots - 1 <= 0) break;
  }

  shuffleInPlace(selected);
  return selected;
}

function buildDiagnosticExam(allQuestions, examSize) {
  const selected = [];
  const usedIds = new Set();

  const questionsByFile = {};
  for (const q of allQuestions) {
    if (!questionsByFile[q.sourceFile]) {
      questionsByFile[q.sourceFile] = [];
    }
    questionsByFile[q.sourceFile].push(q);
  }

  const files = Object.keys(questionsByFile);

  if (files.length > examSize) {
    throw new Error(
      `Diagnostic exam size (${examSize}) is smaller than number of JSON files (${files.length}).`,
    );
  }

  // Ensure at least one question from each JSON file
  for (const file of files) {
    const pool = questionsByFile[file].filter((q) => !usedIds.has(q.id));
    if (pool.length === 0) continue;
    const choice = pool[Math.floor(Math.random() * pool.length)];
    selected.push(choice);
    usedIds.add(choice.id);
  }

  // If there is still room, fill with random remaining questions
  if (selected.length < examSize) {
    const remaining = allQuestions.filter((q) => !usedIds.has(q.id));
    shuffleInPlace(remaining);
    const extraNeeded = examSize - selected.length;
    selected.push(...remaining.slice(0, extraNeeded));
  }

  shuffleInPlace(selected);
  return selected;
}

function markUnscoredQuestions(questions, unscoredFraction) {
  const total = questions.length;
  const targetUnscored = Math.round(total * unscoredFraction);
  const hardIndexes = questions
    .map((q, index) => (q.difficulty === "hard" ? index : -1))
    .filter((index) => index !== -1);

  shuffleInPlace(hardIndexes);

  const countToMark = Math.min(targetUnscored, hardIndexes.length);
  const unscoredIndexSet = new Set(hardIndexes.slice(0, countToMark));

  return questions.map((q, index) => ({
    ...q,
    scored: !unscoredIndexSet.has(index),
  }));
}

function summarizeDomainCounts(questions) {
  const counts = {};
  for (const q of questions) {
    const d = q.domain ?? knToDomain(q.kn) ?? "unknown";
    counts[d] = (counts[d] || 0) + 1;
  }
  return counts;
}

function saveExam(examId, questions) {
  const isDiagnostic = typeof examId === "string" && examId.startsWith("diagnostic-");
  const targetDir = isDiagnostic ? DIAGNOSTIC_EXAMS_DIR : EXAMS_DIR;

  ensureDirExists(targetDir);

  const domainCounts = summarizeDomainCounts(questions);
  const exam = {
    meta: {
      examId,
      totalQuestions: questions.length,
      domainCounts,
      generatedAt: new Date().toISOString(),
    },
    questions,
  };

  let filename;
  if (isDiagnostic) {
    const match = String(examId).match(/diagnostic-(\d+)/);
    const num = match && match[1] ? match[1] : String(examId);
    filename = `diagnostic-exam-${num}.json`;
  } else {
    filename = `practice-exam-${examId}.json`;
  }

  const fullPath = path.join(targetDir, filename);

  fs.writeFileSync(fullPath, JSON.stringify(exam, null, 2), "utf-8");
  console.log(`Saved exam ${examId} to ${fullPath}`);
}

function main() {
  console.log("EPPP Practice Exam Generator");
  console.log("----------------------------");
  console.log(`Questions directory: ${QUESTIONS_DIR}`);
  console.log(`Diagnostic exams directory: ${DIAGNOSTIC_EXAMS_DIR}`);

  const { questionsByDomain, allQuestions } = loadQuestionsByDomain();

  // Diagnostic exams only
  const targets75 = computeTargetCounts(SHORT_EXAM_SIZE);
  console.log("\nTarget questions per domain for each diagnostic exam:");
  for (let d = 1; d <= 8; d += 1) {
    console.log(`  Domain ${d}: ${targets75[d]} questions`);
  }

  for (let i = 1; i <= SHORT_EXAM_COUNT; i += 1) {
    const examLabel = `diagnostic-${i}`;
    console.log(`\nBuilding ${SHORT_EXAM_SIZE}-question diagnostic exam ${examLabel}...`);
    const examQuestions = buildDiagnosticExam(allQuestions, SHORT_EXAM_SIZE);
    // Diagnostic: all items are scored (no unscored set)
    saveExam(examLabel, examQuestions);
  }

  console.log("\nDone.");
}

if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    main();
  } catch (err) {
    console.error("Fatal error:", err.message || err);
    process.exit(1);
  }
}
